(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* :Title: 4D Vector Fields & Stream Plot *)
(* :Summary: Plots four dimensional phase space. *)
(* :Author: Mikica B Kocic *)
(* :Context: StreamPlot4D` *)
(* :Package Version: 1.4 *)


Quiet@Unprotect[ "StreamPlot4D`*", "StreamPlot4D`Private`*" ];
Quiet@Remove[ "StreamPlot4D`*", "StreamPlot4D`Private`*" ];


Quiet@BeginPackage[ "StreamPlot4D`", { "DifferentialEquations`NDSolveUtilities`" } ];


StreamPlot4D::usage = 
"StreadmPlot4D[ {\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"t\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"x\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"y\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"z\", \"TI\"]]\)}, {\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"z\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], \(max\)]\)} ]
generates a stream plot of the vector field {\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"t\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"x\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"y\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"z\", \"TI\"]]\)} as a function of \!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\) and \!\(\*
StyleBox[\"z\", \"TI\"]\).";


SP4D$ProcessData::usage = 
"SP4D$ProcessData[ {\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"t\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"x\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"y\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"z\", \"TI\"]]\)}, {\!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"t\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"x\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"y\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"y\", \"TI\"], \(max\)]\)}, {\!\(\*
StyleBox[\"z\", \"TI\"]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], \(min\)]\),\!\(\*SubscriptBox[
StyleBox[\"z\", \"TI\"], \(max\)]\)} ]
generates vector and streamlines data points for the vector field {\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"t\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"x\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"y\", \"TI\"]]\),\!\(\*SubscriptBox[
StyleBox[\"v\", \"TI\"], 
StyleBox[\"z\", \"TI\"]]\)} \
as a function of \!\(\*
StyleBox[\"t\", \"TI\"]\),\!\(\*
StyleBox[\"x\", \"TI\"]\),\!\(\*
StyleBox[\"y\", \"TI\"]\) and \!\(\*
StyleBox[\"z\", \"TI\"]\).";


VectorFunction::usage = "VectorFunction is an option to StreamPlot4D that emits \
3D graphic primitives which describe how the vector is drawn.";


VectorMaxLength::usage = "VectorMaxLength is an option for the vector field \
visualization functions that determines the longest vector to be drawn.";


VectorScale::usage = "VectorScale is an option for the vector field \
visualization functions that scales the vectors so that the longest vector displayed \
is of the length specified.";


StreamFunction::usage = "StreamFunction is an option to StreamPlot4D that emits \
3D graphic primitives which describe the given streamline path.";


StreamMaxLength::usage = "StreamMaxLength is an option for the vector field \
visualization functions that determines the longest stream line to be drawn.";


StreamScale::usage = "StreamScale is an option for the vector field \
visualization functions that scales the vectors so that the longest stream displayed \
is of the length specified.";


StreamArrowheads::usage = "StreamArrowheads is an option for the \
vector field visualization functions that determines the relative distances at which \
arrowheads are positioned along the streamline (distances are normalized from 0 to 1 \
relative to the length of the streamline).";


ProjectionTo3D::usage = "ProjectionTo3D is an option to StreamPlot4D that determines \
the used projection of the 4D phase space to Graphics3D. The supplied function should \
accept 4D vector and return a 3D vector.";


NDSolveOptions::usage = "NDSolveOptions is an option to StreamPlot4D that specifies \
additional options passed to NDSolve that is used to trace the stream lines.";


NDSolveIterateRange::usage = "Range of independent variable. Default = {-\[Infinity],+\[Infinity]}.";


Boxed4D::usage = "Boxed4D displays the 4D box surrounding the plot range.";


Box4DStyle::usage = "Box4DStyle controls the style of the surrounding 4D box.";


Axes4D::usage = "Axes4D controls the scale of 4D axes (where None turns off an axis).";


Axes4DStyle::usage = "Axes4DStyle controls the style of the 4D axes.";


Axes4DLabels::usage = "Axes4DLabels defines the labels for the 4D axes.";


Axes4DLabelsStyle::usage = "Axes4DLabelsStyle defines the style of the 4D axes labels.";


StreamPlot4D::spvf =
"StreadmPlot4D requires a list of four vector fields followed by range specification.";


Options[ SP4D$ProcessData ] = 
  {
	VectorPoints -> 5, (* Can also be a list of 4D points *)
	StreamPoints -> 3, (* Can also be a list of 4D points *)
	ProgressIndicator -> Automatic, (* True/False or Automatic *)
	Compiled -> False, (* True/False *)
	WorkingPrecision -> MachinePrecision,
	NDSolveOptions -> {}, (* Options passed to NDSolve *)
	NDSolveIterateRange -> { -Infinity, Infinity }
  };


Options[ StreamPlot4D ] = Join[ 
  Options[ Graphics3D ], 
  Options[ SP4D$ProcessData ],
  {
	ProjectionTo3D -> Automatic,
	(* Vector field *)
	VectorColorFunction -> None,
	VectorStyle -> {
		RGBColor[ 0.24, 0.5, 0.76 ],
		Arrowheads[ 0.02 ]
	},
	VectorFunction -> Automatic,
	VectorMaxLength -> Infinity,
	VectorScale -> 1,
	(* Streamlines *)
	StreamColorFunction -> None,
	StreamStyle -> {
		RGBColor[ 0.5, 0.6, 0.6 ],
		Arrowheads[{ 0, 0.02 }]
	},
	StreamArrowheads -> { 0.1, 0.2, 0.3 }, (* can be None *)
	StreamFunction -> Automatic,
	StreamMaxLength -> Infinity,
	StreamScale -> 1,
	Boxed4D -> True,
	Box4DStyle -> Automatic,
	Axes4D -> { 0.4, 0.2, 0.2, 0.2 },
	Axes4DStyle -> { { Gray, Arrowheads[ 0.02 ] } },
	Axes4DLabels -> Automatic,
	Axes4DLabelsStyle -> { Black }
  }
];


SyntaxInformation[ StreamPlot4D ] = {
	"ArgumentsPattern" -> { 
		{_,_,_,_}, 
		{_,_,_}, {_,_,_}, {_,_,_}, {_,_,_}, 
		OptionsPattern[]
	},
	"LocalVariables" -> { "Plot", { 2, 5 } }
};


SyntaxInformation[ SP4D$ProcessData ] = {
	"ArgumentsPattern" -> { 
		{_,_,_,_}, 
		{_,_,_}, {_,_,_}, {_,_,_}, {_,_,_}, 
		OptionsPattern[]
	},
	"LocalVariables" -> { "Plot", { 2, 5 } }
};


Begin["`Private`"];


vectorColorFunction = (Nothing &);
streamColorFunction = (Nothing &);
boundingBox = {};
to3D = (#[[2;;4]] &);
streamlineODE = Null;


progCur = 0;
progMax = 0;
progNb = Null;


makeCubicGrid[ n_, at$X0_: { 0 } ] :=
	If[ n === None \[Or] \[Not]NumericQ@n \[Or] n <= 1, 
	(* Then *)
		{ Nothing },
	(* Else *)
		Tuples[{
			at$X0,
			Subdivide[ X1$min, X1$max, n - 1 ],
			Subdivide[ X2$min, X2$max, n - 1 ],
			Subdivide[ X3$min, X3$max, n - 1 ]
		}]
	];


selectOuterPointsOnGrid[ grid_ ] := 
	Select[ grid,
		#[[2]] == X1$min \[Or] #[[3]] == X2$min \[Or] #[[3]] == X3$min \[Or]
		#[[2]] == X1$max \[Or] #[[3]] == X2$max \[Or] #[[3]] == X3$max &
	]


defaultProjectionTo3D[{ t_, x_, y_, z_ }] := 
With[ 
	{ scale = X0$max / ( X0$max + t ) },
	{ scale x, scale y, scale z }
]


simpleProjectionTo3D[{ t_, x_, y_, z_ }] := { x, y, z }


rescaleToBB[ point_ ] :=	
{
	Rescale[ point[[1]], boundingBox[[1]], { -1, 1 } ],
	Rescale[ point[[2]], boundingBox[[2]], { -1, 1 } ],
	Rescale[ point[[3]], boundingBox[[3]], { -1, 1 } ] 
}


drawBox4D[ boxStyle_ ] :=
  With[
	{ vertices = Tuples[{ 
		{ X0$min, X0$max }, { X1$min, X1$max }, 
		{ X2$min, X2$max }, { X3$min, X3$max } 
	  }]
	},
	Flatten@Join[
		If[ boxStyle === Automatic, {}, { boxStyle } ],
		EdgeList@ HypercubeGraph[4] /. UndirectedEdge[ a_, b_ ] :> 
		  Line[
			{ to3D@vertices[[a]], to3D@vertices[[b]] },
			Sequence@@ If[ boxStyle =!= Automatic, {},
			  { VertexColors -> { 
				streamColorFunction@vertices[[a]], 
				streamColorFunction@vertices[[b]] 
			  } }
			]
		  ]
	] (* Join *)
  ] (* With *)


drawAxes4D[ axesScale_, axesStyle_, axesLabels_, axesLabelsStyle_ ] :=
  With[
	{ vertices = Tuples[{ 
		{ X0$min, X0$max }, { X1$min, X1$max }, 
		{ X2$min, X2$max }, { X3$min, X3$max } 
	  }]
	},
	Flatten@Join[
		With[ 
		  {
			p1a = to3D@{ X0$min, X1$min, X2$min, X3$min },
			p1b = to3D@{ X0$max, X1$min, X2$min, X3$min },
			p2a = to3D@{ X0$min, X1$min, X2$min, X3$min },
			p2b = to3D@{ X0$min, X1$max, X2$min, X3$min },
			p3a = to3D@{ X0$min, X1$min, X2$min, X3$min },
			p3b = to3D@{ X0$min, X1$min, X2$max, X3$min },
			p4a = to3D@{ X0$min, X1$min, X2$min, X3$min },
			p4b = to3D@{ X0$min, X1$min, X2$min, X3$max }
		  },
		  {
			(* Axes *)
			If[ axesStyle === Automatic \[Or]
				Not@ListQ@axesStyle,
				(* Then *) Nothing,
				(* Else *) axesStyle
			],
			If[ ListQ@axesStyle \[And] Length@axesStyle >= 1,
				axesStyle[[1]], Nothing
			],
			Arrow@Tube[ { p1a, p1a + axesScale[[1]] ( p1b - p1a ) } ],
			If[ ListQ@axesStyle \[And] Length@axesStyle >= 2,
				axesStyle[[2]], Nothing
			],
			Arrow@Tube[ { p2a, p2a + axesScale[[2]] ( p2b - p2a ) } ],
			If[ ListQ@axesStyle \[And] Length@axesStyle >= 3,
				axesStyle[[3]], Nothing
			],
			Arrow@Tube[ { p3a, p3a + axesScale[[3]] ( p3b - p3a ) } ],
			If[ ListQ@axesStyle \[And] Length@axesStyle >= 4,
				axesStyle[[4]], Nothing
			],
			Arrow@Tube[ { p4a, p4a + axesScale[[4]] ( p4b - p4a ) } ],
			(* Axes Labels *)
			If[ axesLabelsStyle === Automatic \[Or] 
				Not@ListQ@axesLabelsStyle, 
				(* Then *) Nothing,
				(* Else *) axesLabelsStyle
			],
			If[ ListQ@axesLabelsStyle \[And] Length@axesLabelsStyle >= 1,
				axesLabelsStyle[[1]], Nothing
			],
			Text[ axesLabels[[1]], p1a + 1.2 axesScale[[1]] ( p1b - p1a ) ],
			If[ ListQ@axesLabelsStyle \[And] Length@axesLabelsStyle >= 2,
				axesLabelsStyle[[2]], Nothing
			],
			Text[ axesLabels[[2]], p2a + 1.2 axesScale[[2]] ( p2b - p2a ) ],
			If[ ListQ@axesLabelsStyle \[And] Length@axesLabelsStyle >= 3,
				axesLabelsStyle[[3]], Nothing
			],
			Text[ axesLabels[[3]], p3a + 1.2 axesScale[[3]] ( p3b - p3a ) ],
			If[ ListQ@axesLabelsStyle \[And] Length@axesLabelsStyle >= 4,
				axesLabelsStyle[[4]], Nothing
			],
			Text[ axesLabels[[4]], p4a + 1.2 axesScale[[4]] ( p4b - p4a ) ]
		  }
		] (* With *)
	] (* Join *)
  ] (* With *)


SP4D$ProcessData[
	{ Vt_, Vx_, Vy_, Vz_ },
	{ t_Symbol, tMin_?NumericQ, tMax_?NumericQ },
	{ x_Symbol, xMin_?NumericQ, xMax_?NumericQ },
	{ y_Symbol, yMin_?NumericQ, yMax_?NumericQ },
	{ z_Symbol, zMin_?NumericQ, zMax_?NumericQ },
	opts : OptionsPattern[]
] :=
Block[
{
	boundingBox4D,
	vectorPoints = OptionValue[ VectorPoints ],
	vectorGrid, vectorFieldDataPoints,
	streamPoints = OptionValue[ StreamPoints ],
	streamGrid, streamlinesDataPoints
},
	(**************************************************************************)
	(* Setup global ranges of coordinates *)

	{ X0$min, X0$max } = MinMax[{ tMin, tMax }];
	{ X1$min, X1$max } = MinMax[{ xMin, xMax }];
	{ X2$min, X2$max } = MinMax[{ yMin, yMax }];
	{ X3$min, X3$max } = MinMax[{ zMin, zMax }];

	(**************************************************************************)
	(* Construct the vector and stream point grids *)

	vectorGrid = If[ ArrayQ@vectorPoints, 
		vectorPoints,
		makeCubicGrid[ vectorPoints, Subdivide[ X0$min, X0$max, 3 ] ] // 
			selectOuterPointsOnGrid
	];

	streamGrid = If[ ArrayQ@streamPoints, 
		streamPoints,
		makeCubicGrid[ streamPoints, { X0$min } ]
	];

	(**************************************************************************)
	(* Start the progress indicator *)

	progCur = 0;
	progMax = Length@vectorGrid + 40 Length@streamGrid;
	progNb = Null;

	If[ OptionValue[ ProgressIndicator ] === True \[Or] 
		( OptionValue[ ProgressIndicator ] === Automatic \[And] progMax > 1000 ),
		beginProgress []
	];

	(**************************************************************************)
	(* Instantiate (and optionally compile) the vector field functions *)

	Quiet@ClearAll[ "StreamPlot4D`Private`D$X*" ];

	If[ OptionValue[ Compiled ],
	(* Then *)
		D$X0 = Compile[ { a, b, c, d }, Evaluate[ Vt /. { t -> a, x -> b, y -> c, z -> d } ] ];
		D$X1 = Compile[ { a, b, c, d }, Evaluate[ Vx /. { t -> a, x -> b, y -> c, z -> d } ] ];
		D$X2 = Compile[ { a, b, c, d }, Evaluate[ Vy /. { t -> a, x -> b, y -> c, z -> d } ] ];
		D$X3 = Compile[ { a, b, c, d }, Evaluate[ Vz /. { t -> a, x -> b, y -> c, z -> d } ] ],
	(* Else *)
		D$X0[ a_, b_, c_, d_ ] = Vt /. { t -> a, x -> b, y -> c, z -> d };
		D$X1[ a_, b_, c_, d_ ] = Vx /. { t -> a, x -> b, y -> c, z -> d };
		D$X2[ a_, b_, c_, d_ ] = Vy /. { t -> a, x -> b, y -> c, z -> d };
		D$X3[ a_, b_, c_, d_ ] = Vz /. { t -> a, x -> b, y -> c, z -> d }
	];

	(**************************************************************************)
	(* Calculate vectors on the grid *)

	vectorFieldDataPoints = ( 
		progCur++;
		{ #, { D$X0@@#, D$X1@@#, D$X2@@#, D$X3@@# } }
	) & /@ vectorGrid;

	(**************************************************************************)
	(* Setup the stream line ODE *)

	(* Integration bounds *)
	X0$int = MinMax[{ tMin, tMax }];
	X1$int = MinMax[{ xMin, xMax }, Scaled[5] ];
	X2$int = MinMax[{ yMin, yMax }, Scaled[5] ];
	X3$int = MinMax[{ zMin, zMax }, Scaled[5] ];
	\[Xi]$Range = OptionValue[ NDSolveIterateRange ];

	streamlineODE = Quiet@ First@ NDSolve`ProcessEquations[
	  {
		D[ X0[\[Xi]], \[Xi] ] == D$X0[ X0[\[Xi]], X1[\[Xi]], X2[\[Xi]], X3[\[Xi]] ],
		D[ X1[\[Xi]], \[Xi] ] == D$X1[ X0[\[Xi]], X1[\[Xi]], X2[\[Xi]], X3[\[Xi]] ],
		D[ X2[\[Xi]], \[Xi] ] == D$X2[ X0[\[Xi]], X1[\[Xi]], X2[\[Xi]], X3[\[Xi]] ],
		D[ X3[\[Xi]], \[Xi] ] == D$X3[ X0[\[Xi]] ,X1[\[Xi]], X2[\[Xi]], X3[\[Xi]] ],
		X0[0] == 0,
		X1[0] == 0,
		X2[0] == 0,
		X3[0] == 0,
		WhenEvent[
			Not@Between[ X0[\[Xi]], X0$int ] \[Or]
			Not@Between[ X1[\[Xi]], X1$int ] \[Or]
			Not@Between[ X2[\[Xi]], X2$int ] \[Or]
			Not@Between[ X3[\[Xi]], X3$int ],
			"StopIntegration"
		]
	  },
	  { X0, X1, X2, X3 },
	  \[Xi],
	  WorkingPrecision -> OptionValue[ WorkingPrecision ],
	  Sequence@@OptionValue[ NDSolveOptions ]
	];

	(**************************************************************************)
	(* Solve ODE all the streamlines passing through the grid points *)

	boundingBox4D = {
		{ X0$min, X1$min, X2$min, X3$min },
		{ X0$max, X1$max, X2$max, X3$max }
	};

	streamlinesDataPoints = (
		With[ 
			{ streamline = solveStreamline[#] },
			boundingBox4D = CoordinateBoundingBox@Join[
				boundingBox4D,
				CoordinateBoundingBox[ streamline ]
			];
			progCur += 40;
			streamline
		]
	) & /@ streamGrid;

	boundingBox4D = Transpose@boundingBox4D;

	(**************************************************************************)
	(* Close the progress indicator (if any) *)

	If[ progNb =!= Null, endProgress [] ];

	(**************************************************************************)
	(* The result is the list of vectors (a pair of point and vector) 
	    and the list of streamlines (a collection of points) *)
	{ vectorFieldDataPoints, streamlinesDataPoints, streamPoints, boundingBox4D }
]


StreamPlot4D[
	{ Vt_, Vx_, Vy_, Vz_ },
	{ t_Symbol, tMin_?NumericQ, tMax_?NumericQ },
	{ x_Symbol, xMin_?NumericQ, xMax_?NumericQ },
	{ y_Symbol, yMin_?NumericQ, yMax_?NumericQ },
	{ z_Symbol, zMin_?NumericQ, zMax_?NumericQ },
	opts : OptionsPattern[]
] :=
Block[
  {
	plotRange, boundingBox4D, bbExp,
	drawVector = If[ OptionValue[ VectorFunction ] === Automatic,
	  Function[ { points (*3D*), vector }, { 
		vectorColorFunction[ vector[[1]] ], 
		Arrow[ points ] 
	  } ], 
	  (* Else *) OptionValue[ VectorFunction ]
	],
	vectorStyle = OptionValue[ VectorStyle ],
	vectorScale = OptionValue[ VectorScale ],
	vectorFieldDataPoints, vectors,
	drawStreamline = If[ OptionValue[ StreamFunction ] === Automatic,
	  Function[ { points (*3D*), trajectory, range }, { 
		streamColorFunction[ trajectory[[-1]] ],
		If[ range[[2]] === \[Infinity], (* the last segment was not specified *)
			Line[ points, VertexColors -> streamColorFunction /@ trajectory ], 
			Arrow@Line[ points, VertexColors -> streamColorFunction /@ trajectory ]
		]
	  } ],
	  (* Else *) OptionValue[ StreamFunction ]
	],
	streamStyle = OptionValue[ StreamStyle ],
	streamArrowheads = If[ OptionValue[ StreamArrowheads ] === None,
		{}, OptionValue[ StreamArrowheads ]
	],
	streamlinesDataPoints, streamlines, streamPoints
  },
	(**************************************************************************)
    (* Calculate vector field and solve streamlines *)

	{ vectorFieldDataPoints, streamlinesDataPoints, streamPoints, boundingBox4D } 
	  = SP4D$ProcessData[
			{ Vt, Vx, Vy, Vz },
			{ t, tMin, tMax },
			{ x, xMin, xMax },
			{ y, yMin, yMax },
			{ z, zMin, zMax },
			Sequence@@FilterRules[ {opts}, Options[ SP4D$ProcessData ] ]
		];

	(**************************************************************************)
	(* If PlotRange is Full, use the bounding box of the streamlines *)

	plotRange = If[ MemberQ[ { Full, Automatic }, OptionValue[ PlotRange ] ], 
		(* Then *) 1, 
		(* Else *) OptionValue[ PlotRange ] 
	];

	boundingBox = If[ 
		OptionValue[ PlotRange ] === Full \[And] boundingBox4D =!= {}, 
	(* Then *)
		boundingBox4D[[2;;4]],
	(* Else (default) *)
		{ { X1$min, X1$max }, { X2$min, X2$max }, { X3$min, X3$max } }
	];

	bbExp = Round[ RealExponent@Min@# - 0.3 ] & /@ boundingBox;

	(**************************************************************************)
    (* Draw the vector field and the streamlines *)

	to3D = If[ OptionValue[ ProjectionTo3D ] === Automatic,
	  (* Then *) rescaleToBB[ defaultProjectionTo3D[ # ] ] &, 
	  (* Else *) rescaleToBB[ OptionValue[ ProjectionTo3D ][ # ] ] &
	];

	vectorColorFunction = If[ OptionValue[ VectorColorFunction ] === None,
		(Nothing &),
		OptionValue[ VectorColorFunction ]
	];

	streamColorFunction = If[ OptionValue[ StreamColorFunction ] === None,
		(Nothing &),
		OptionValue[ StreamColorFunction ]
	];

	vectors = (
		With[ { from = to3D[ #[[1]] ] },
		With[ { to = from + vectorScale ( to3D[ #[[1]] + #[[2]] ] - from ) },
			drawVector[ { from, to }, # ]
		]]
	) & /@ vectorFieldDataPoints;

	streamlines = (
		drawStreamline@@# & /@ 
			combinedSplitStreamline[ to3D /@ #, #, streamArrowheads ]
	) & /@ streamlinesDataPoints;

	(**************************************************************************)
	(* Compose the vectors and the stream lines into 3D Graphics *)

	Graphics3D[
	(* Primitives *)
	  {
		Flatten@ {
		  If[ ListQ@vectorStyle, vectorStyle, {vectorStyle} ],
		  vectors
		},
		Flatten@ {
		  If[ ListQ@streamStyle, streamStyle, {streamStyle} ],
		  If[ ListQ@streamPoints, 
			Point[ to3D /@ streamPoints, 
				VertexColors -> ( streamColorFunction /@ streamPoints ) ],
			(* Else *) Nothing
		  ],
		  streamlines
		},
		(* Plot the 4D box *)
		If[ Not@OptionValue[ Boxed4D ], 
			(* Then *) {Nothing}, 
			(* Else *) drawBox4D[ OptionValue[ Box4DStyle ] ]
		],
		(* Plot the 4D axes *)
		If[
			OptionValue[ Axes4D ] === False \[Or] 
			OptionValue[ Axes4D ] === None,
		(* Then *) 
			{Nothing},
		(* Else option Axes4D is either True or defines the scale *)
			drawAxes4D[
				If[ NumberQ@OptionValue[ Axes4D ],
					Table[ OptionValue[ Axes4D ], 4 ],
					OptionValue[ Axes4D ]
				],
				OptionValue[ Axes4DStyle ],
				If[ OptionValue[ Axes4DLabels ] === Automatic,
					{ t, x, y, z },
					OptionValue[ Axes4DLabels ]
				], 
				OptionValue[ Axes4DLabelsStyle ]
			]
		]
	  },
	(* Options *)
	  {
		Sequence@@Evaluate@FilterRules[ 
		  FilterRules[ {opts}, Except[ PlotRange ] ],
		  Options[ Graphics3D ]
		],
		PlotRange -> plotRange,
		BoxRatios -> { 1, 1, 1 },
		AxesLabel -> Evaluate@If[ 
		  OptionValue[ Axes4DLabels ] === Automatic \[Or] 
		  Not@ListQ@OptionValue[ Axes4DLabels ], 
		  (* Then *) { 
			Row@{ x, Sequence@@If[ bbExp[[1]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[1]],0] } ] }, 
			Row@{ y, Sequence@@If[ bbExp[[2]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[2]],0] } ] }, 
			Row@{ z, Sequence@@If[ bbExp[[3]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[3]],0] } ] }
		  },
		  (* Else *) {
			Row@{ OptionValue[ Axes4DLabels ][[2]], Sequence@@If[ bbExp[[1]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[1]],0] } ] }, 
			Row@{ OptionValue[ Axes4DLabels ][[3]], Sequence@@If[ bbExp[[2]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[2]],0] } ] }, 
			Row@{ OptionValue[ Axes4DLabels ][[4]], Sequence@@If[ bbExp[[3]] == 0, {}, 
				{ " /", HoldForm[10]^NumberForm[bbExp[[3]],0] } ] }
		  }
		], 
		Ticks -> ( {
		  { -1, NumberForm[ boundingBox[[#,1]] / 10.^bbExp[[#]], {Infinity,1} ] }, 
		  { Rescale[ 0, boundingBox[[#]], { -1, 1 } ], NumberForm[ 0, {Infinity,1} ] },
		  { 1, NumberForm[ boundingBox[[#,2]] / 10.^bbExp[[#]], {Infinity,1} ] } 
		} & /@ {1,2,3} )
	  }
	]
]


(*  *)
StreamPlot4D[ ___ ] := Null /; (
	Message[ StreamPlot4D::spvf ]; False
)


solveStreamline[ point_ ]:=
Block[
{ state, sol = {} },

	(* Reinitialize streamlineODE (created by ProcessEquations)
	   with new initial values, then iterate (i.e., solve ODE).
	 *)
	state = First@ NDSolve`Reinitialize[ streamlineODE, {
		X0[0] == point[[1]],
		X1[0] == point[[2]],
		X2[0] == point[[3]],
		X3[0] == point[[4]]
	}];

	Quiet@NDSolve`Iterate[ state, \[Xi]$Range ];
	sol = NDSolve`ProcessSolutions[ state ];

	Transpose@{ 
		( X0 /. sol )["ValuesOnGrid"],
		( X1 /. sol )["ValuesOnGrid"],
		( X2 /. sol )["ValuesOnGrid"],
		( X3 /. sol )["ValuesOnGrid"]
	}
]


beginProgress [] := 
(
	progCur = 0;
	progNb = CreateWindow[ 
	  DialogNotebook[
		{
		  ExpressionCell[
			ProgressIndicator[ 
				Dynamic@progCur, { 0, progMax }, ImageSize -> 300 
			],
			"Text", CellMargins -> {{10,10},{5,10}}
		  ],
		  ExpressionCell[
			DefaultButton[" Cancel ",
				FrontEndExecute@FrontEndToken@"EvaluatorAbort";
				endProgress [];
				DialogReturn []
			], "Text", 
			TextAlignment -> Center, CellMargins -> {{10,10},{0,10}}
		  ]
		}, 
		{ 
		  WindowTitle -> "StreamPlot4D: Formatting data ...",
		  WindowFloating -> True,
		  WindowStatusArea -> Dynamic[ "Elapsed time: " <>
				ToString@Round[ Clock[ Infinity ] ] <> " s" 
		  ],
		  WindowElements -> { "StatusArea", "MemoryMonitor" } 
		}
	  ]
	];
)


endProgress [] := 
(
	Quiet@SetOptions[ progNb, { Visible -> False } ];
	Quiet@NotebookClose[ progNb ];
	progNb = Null;
	progCur = 0;
)


splitStreamline[ 
	p_,         (* The coordinate points array. *) 
	atLen_,     (* The list of lengths \[Element] (0,1) at which to split p *)
	range_: All (* The range over coordinates to track length. *)
] :=
Block[
  {
	split, n, m, q, lastp, lastq, k, midp
  },
  split = Join[ Union@Select[ atLen, 0 < # < 1 & ], {1} ];
  (* split should contain sorted values between 0 and 1, ending with 1 *)
  If[ Length@p <= 1 \[Or] Length@split <= 1,
  (* Then, nothing to do *)
	{ p },
  (* Else, p and m contain at least two elements *)
	q = {0} ~Join~ Accumulate[ Norm /@ ( p[[2;;-1,range]] - p[[1;;-2,range]] ) ];
	If[ q[[-1]] == 0, Return@{ p } ];
	q = q / q[[-1]]; (* The running length along p normalized to 1 *)
	lastp = p[[1]];
	lastq = q[[1]];
	Reap[
	  n = m = 1;
	  While[ n <= Length@p,
		If[ m >= Length@split,
		(* Then, at the end of split, just emit all p's *)
			Sow[ p[[n]], 1 ];
			lastp = p[[n]]; lastq = q[[n]]; n++,
		(* Else *)
			If[ q[[n]] < split[[m]],
			(* Then, the length of current p is below the next split *)
				Sow[ p[[n]], split[[m]] ]; 
				lastp = p[[n]]; lastq = q[[n]]; n++,
			(* Else, the running length exceeded the next split *)
				k = If[ q[[n]] == lastq, 1,
					( split[[m]] - lastq ) / ( q[[n]] - lastq ) 
				];
				midp = lastp + k ( p[[n]] - lastp );
				If[ midp[[range]] != lastp[[range]], 
					Sow[ midp, split[[m]] ]
				];
				lastp = midp; lastq = split[[m]]; m++;
				Sow[ midp, split[[m]] ];
				(* If we are below the next split, 
					we can emit the current point *)
				If[ q[[n]] < split[[m]],
					If[ midp[[range]] != p[[n,range]], 
						Sow[ p[[n]], split[[m]] ]
					];
					lastp = p[[n]]; lastq = q[[n]]; n++
				];
			] (* EndIf q\[LeftDoubleBracket]n\[RightDoubleBracket] < split\[LeftDoubleBracket]m\[RightDoubleBracket] *)
		] (* EndIf m \[GreaterEqual] Length@split *)
	  ] (* While *)
	][[2]] (* Reap *)
  ] (* If *)
]


combinedSplitStreamline[ p3D_, p4D_, atLen_ ] := 
With[
  {
	strlist = splitStreamline[ Join[ p3D, p4D, 2 ], atLen, 1;;3 ],
	split = Join[ 
		If[ MemberQ[ Rationalize@atLen, 0 ], {0}, {-\[Infinity]} ], 
		Union@Select[ atLen, 0 < # < 1 & ], 
		If[ MemberQ[ Rationalize@atLen, 1 ], {1}, {\[Infinity]} ] 
	]
  },
	Reap[
		Do[
			Sow[ { 
				strlist[[n]][[All,1;;3]],   (* 3D points *)
				strlist[[n]][[All,4;;-1]],  (* 4D points *)
				split[[n;;n+1]]           (* Split range *)
			} ],
			{ n, Length@strlist }
		]
	][[2,1]]
]


End[];


SetAttributes[ SP4D$ProcessData, { HoldFirst, ReadProtected } ];
SetAttributes[ StreamPlot4D, { HoldFirst, ReadProtected } ];
Protect[ 
	StreamPlot4D, NDSolveOptions, ProjectionTo3D,
	VectorFunction, VectorMaxLength,
	StreamArrowheads, StreamFunction, StreamMaxLength,
	Boxed4D, Box4DStyle, 
	Axes4D, Axes4DStyle, Axes4DLabels, Axes4DLabelsStyle
];


EndPackage[]



